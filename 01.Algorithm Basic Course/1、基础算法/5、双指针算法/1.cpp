// 思路：双指针算法
// 维护一段最长的不包含重复的数的连续区间[j, i]
// 用s[i]数组维护[j, i]区间出现的数的个数
// 1. 初始化j = 0, i = 0;
// 2. 从i = 0开始往后走, s[a[i]] ++ ;
// 3. 判断s[a[i]]是否大于1, 如果不大于1, 此时更新最长距离res
// 4. 如果大于1, 则更新出现重复, j开始增加到i这个位置, 每次j++都的先把s[a[j]减一





// 核心思路：

// 1、遍历数组a中的每一个元素a[i], 对于每一个i，找到j使得双指针[j, i]维护的是以a[i]结尾的最长连续不重复子序列，
// 长度为i - j + 1, 将这一长度与r的较大者更新给r。
// 2、对于每一个i，如何确定j的位置：由于[j, i - 1]是前一步得到的最长连续不重复子序列，
// 所以如果[j, i]中有重复元素，一定是a[i]，因此右移j直到a[i]不重复为止（由于[j, i - 1]已经是前一步的最优解，
// 此时j只可能右移以剔除重复元素a[i]，不可能左移增加元素，因此，j具有“单调性”、本题可用双指针降低复杂度）。
// 3、用数组s记录子序列a[j ~ i]中各元素出现次数，遍历过程中对于每一个i有四步操作：
// cin元素a[i] -> 将a[i]出现次数s[a[i]]加1 -> 若a[i]重复则右移j（s[a[j]]要减1） -> 确定j及更新当前长度i - j + 1给r。

// 注意细节：

// 当a[i]重复时，先把a[j]次数减1，再右移j。


























#include <iostream>

using namespace std;

const int N = 100010;

int a[N], b[N];

int main(){
    int n, res = 0;
    cin >> n;
    
    for (int i = 0, j = 0; i < n; i ++ ){
        cin >> a[i];
        b[a[i]] ++ ;
        while (b[a[i]] > 1) --b[a[j++]];
        res = max(res, i - j + 1);
    }
    cout << res << endl;
}