其实Dijkstra算法就是BFS+贪心
dj算法的缺点在于，它不能处理有负权值的边的图，比如某条边的长度为-1。
为什么呢，因为dj算法是贪心BFS，而BFS有一个特点，就是短视！
它只能看到与自己相邻的点的情况，但是对于远方，它就一脸蒙蔽了。
如果有一条边是负的，他不知道多走这一条边是能减小dis的，所以
dj算法不能处理带负权边的图。


Dijkstra朴素算法思路：	->	O(n^2)
设置一个集合S记录已求得的最短路径的顶点，设置一个辅助数组dist[],记录从源点
到顶点i之间的最短路径。
1.初始化：dist[]初始为0x3f3f3f3f,dist[1] = 0;
2.从V-S中选出Vj,Vj就是当前求得的一条从V0出发的最短路径的终点。()
注意：和书上算法描述不一样,这里并没有把初始点放入S中,所以此时S集合为空。
第一次循环只是为了把初始点加入S集合。然后更新初始点可以到达的其他点的距离。
第二次循环就找到与初始点距离最小的那个点并将其加入S集合,再用这个点更新到V-S集合中的点的距离。
3.更新第二步V-S中加入的那个点是否可以更新初始点到V-S集合中的点的最短距离。

//思路写的很好：https://www.cnblogs.com/fusiwei/p/11390537.html
Dijkstra堆优化算法思路：	->	O(mlogn)

Prim算法思路：i = 0;时主要是判断第一次循环时的初始化并区分是否要更新权值和
//寻找离集合S最近的点
//判断是否连通，有无最小生成树
//更新最新S的权值和

if (i && dis[t] == INF) 和if(I)这步	->	当集合S为空的时候的特判
int t=-1 的作用怎么理解呀				->	可以理解 为 当第一次初始化用吧

联系：Dijkstra算法是更新到起始点的距离，Prim是更新到集合S的距离