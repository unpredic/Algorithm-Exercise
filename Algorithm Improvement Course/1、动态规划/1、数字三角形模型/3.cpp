/*
这是一种类似贪心的解法，第一次选择最大的，然后把最大路径上的数字都置为空，第二次再选择最大的。
这就是"只见树木不见森林"的方法:

第一次走为局部最优并且也对第二次走造成了影响，第二次走是在第一次影响下所能走的局部最优，
不具备无后效性，因此分开两次走并不是全局最优解。

举一个反例来证明，
9 0 3
0 9 2
0 2 0
最长路径是9+9+2=20，假设这次走的路线是第一行的9、第二行的9和2，那么在第二次走的时候，地图变成
0 0 3
0 0 0
0 2 0
显然最长路径是3，总和为23。

然而这不是最优解，最优解是第一次走第一行的9、第二行的9、第三行的2（仍是20），
但第二次可以走第一行的3、第二行的2，得到5，总和达到25。

两个小朋友一起走为什么就行呢？因为他们在一起整体考虑，互相关心互相照顾，彼此能知道对方走了哪个点，
自己在不影响最优取值的情况下，尽可能的取次优的点，这样，就可以得到全局最优解。
*/

// f[k][i1][i2]:

#include <iostream>

using namespace std;

const int N = 15;

int n;
int w[N][N];
int f[N * 2][N][N];

int main() {
    
    scanf("%d", &n);
    
    int a, b, c;
    while (scanf("%d%d%d", &a, &b, &c), a || b || c) {
        w[a][b] = c;
    }
    
    for (int k = 2; k <= n + n; k ++ ) {
        for (int i1 = 1; i1 <= n; i1 ++ ) {
            for (int i2 = 1; i2 <= n; i2 ++ ) {
                int j1 = k - i1, j2 = k - i2;
                if (j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n) {
                    int t = w[i1][j1];  // 重合只需加一个权重
                    if (i1 != i2) t += w[i2][j2];   // 不重合需要加两个权重
                    int &x = f[k][i1][i2]; // 引用
                    // 0:代表小朋友要到下边一个格子
                    // 1:代表小朋友要到右边一个格子
                    x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);   // 00
                    x = max(x, f[k - 1][i1 - 1][i2] + t);       // 01
                    x = max(x, f[k - 1][i1][i2 - 1] + t);       // 10
                    x = max(x, f[k - 1][i1][i2] + t);           // 11
                }
            }
        }
    }
    
    printf("%d\n", f[n + n][n][n]);
    
    return 0;
}